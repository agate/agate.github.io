---
title: "三说Spring的AOP"
date: 2008-01-26
tags:
---

连续写了两次AOP的文章，总是觉得没有吧AOP说得很清楚。而且网络上每一篇AOP的教程都是充斥着大量专业术语，令人甚是费解。打算把各个术语根据spring这个aop的实现来串讲一边。

还是从“日志记录说起吧”，几乎我们所有的程序中都需要记录日志的，这是一个共通的需求。

如果我们要把日志记录提取出来，作为一个抽象的独立的服务我们可以叫它为 Advice （“通知”，说白了，advice就是一个功能逻辑）。

然后我们将这个“功能逻辑 ”-advice 加入到我们需要的地方，而这个地方就是我们所谓的 PointCut ，（“切入点”，我们使用中最常看到的就无非是：方法前、方法后、出异常时等等）。

重复上一篇文章的话：我们的 Aspect  = Advice + PointCut 这样我们就形成了我们AOP最为基础“切面”

那么我们要把这个 advice  加在哪里呢？也就是说这个PointCut在哪里呢？这个就是我们所谓的 Target （“目标对象”）。我们的目标说白了也就是目标对象中的某些需要我们这个日志服务的方法罢了。

OK，我们有了我们的“通知”、“切入点”，也有了我们的“目标对象”，那么将“通知”加入到“目标对象”的“切入点”的动作就叫 weaving （“织入”）。呵呵，这个当然是有spring容器在运行时执行的咯，但是多我们来说就是在applicationContext.xml中加入对应的配置段咯。

这里，还有一个名词 Proxy （“代理对象”），如何理解这个词呢？它在实际使用中又是什么呢？我为此特别画了一张图：

<img src="http://pic.yupoo.com/skyforce/407814fe25ae/bm4wh53h.jpg" height="352" width="492" />

所谓 Proxy 这个代理，说白了，在 Spring 的 AOP 应用中，就是将你那些需要插入服务的目标对象在一个新的、模拟好你这些目标对象的现有方法接口的一个新的对象。正如我画的这个图所示，其实在程序运行过程中我们使用的比不是我们自己设计出来的那个“DiyBean”，而是由 Spring 容器自动生成的一个对象“DiyBeanProxy”。我们调用的那些被声明配置过的方法时，也不是用我们对象默认的方法，而是根据配置的不同，重新生成的代理对象中的对应方法。就比如我们这图中的“methodTwo()”方法，代理对象中的(1)、(2)方法段其实就是对应着的就是切入点的功能啦，(1)就是等于“beforeMethod”，(2)就是相应的“afterMethod”了（当然还有在抛出异常的时候的服务我没有画出）。

综合来说，AOP不是什么特新的思想，就是我们一切业内的术语过于专业、抽象。不就是一个拦截，一个重新打包的过程嘛！不难！
